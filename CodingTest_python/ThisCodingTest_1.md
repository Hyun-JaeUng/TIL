# (이코테 2021) 1. 코딩 테스트 출제 경향 분석 및 파이썬 문법 부수기

> 21.01.02 작성
>
> [이코테 1번 강의 by 동빈나](https://www.youtube.com/watch?v=m-9pAwq1o3w&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC)

## 1강) 코딩 테스트 개요 및 출제 경향

* 파이썬 온라인 개발 환경 : __리플릿__,  파이썬 튜터 
  * [리플릿 주소](https://repl.it/languages/python3)

* 파이썬 오프라인 개발 환경 : 파이참
* 알고리즘 코딩 테스트를 준비하는 과정에서 자신만의 소스코드를 관리하는 습관을 들이는 것이 좋다. 

## 2강) 알고리즘 성능 평가

* 복잡도는 알고리즘의 성능을 나타내는 척도를 말하여 낮을 수록 좋다. 
* ex) 시간 복잡도, 공간 복잡도

### 빅오 표기법

* 가장 빠르게 증가하는 항만을 고려하는 표기법
  * 함수의 상한만을 나타낸다.
* 상수 시간 > 로그 시간 > 선형 시간 순으로 좋다. 
  * 수행시간을 예측해서 알고리즘을 설계해야됨. 
  * 효율적이지 못한 코드는 통상 1~5초 가량인 시간제한에 걸림.
* N의 범위에 따라 문제 풀 수 있는 시간복잡도 설명했음. (스스로 감을 찾아나가야 함)

### 일반적인 알고리즘 문제 해결 과정

1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

* 대부분은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출시함! 
* 문제에 접근할 때부터 생각나는 내용을 바로 소스코드로 옮기기 보다는 문제에 대한 온전한 이해와 어떤식으로 코드를 작성해 나갈 것인가까지 확실히 정리를 하고, 문제 푸는걸 추천함.

### 수행 시간 측정 소스코드 예제

``` python
import time
start_time = time.time() #측정 시작

#프로그램 소스코드
end_time = time.time() # 측정 종료
print("time:", end_time - start_time) # 수행 시간 출력
```

## 3강) 파이썬 문법 - 수 자료형

> **모든 프로그래밍은 결국 데이터를 다루는 행위**이므로 자료형에 대한 이해는 필수
>
> 파이썬의 자료형으로는 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전 등이 있음.

#### 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전!!

### 정수형 (int)

* 정수형은 정수를 다루는 자료형 

  * 양의 정수, 음의 정수, 0이 포함

* 코테에서 주로 정수형을 많이 다룬다.

  ex) ` a = 1000` , `a = -1` , ` a=0` 

### 실수형(float)

* 실수형은 소수점 아래의 데이터를 포함하는 수 자료형 
  * 파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 자동으로 처리.
  * 소수부가 0이거나, 정수부가 0인 소수는 0을 생략하고 작성할 수 있다.
  * `a = - .7`  은 0.7을 의미

### 지수 표현 방식

* 파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다.

  * e나 E 다음에 오는 수는 **10의 지수부**를 의미함.
  * 예를 들어 1e9라고 입력하게 되면, 10의 9제곱이 됨 => **유효숫자e^지수**
  * 임의의 큰 수를 표현하기 위해 자주 사용됨.
  * 최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 **무한(INF)** 으로 설정하곤 함
  * 이 때 가능한 최댓값이 10억 미만이라면 무한의 값으로 `1e9`를 이용할 수 있음.

* 실수형으로 자동으로 표현되기 떄문에 정수로 바꾸기 위해서는 `int(1e9)` 변환이 필요함

### 실수형 더 알아보기

* __컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 가짐__

  ```python
  a = 0.3 + 0.6
  print(a)
  
  if a == 0.9:
      print (True)
  else: 
      print (False)
  ```

  실행 결과는 `0.89999999999` => `False` 가 나옴.

* 개발 과정에서 실수 값을 제대로 비교하지 못해서 원하는 결과를 얻지 못할 수 있음.
* 이럴 때는 **round()** 함수를 이용할 수 있으며, 이러한 방법이 권장됨.
* 예를 들어 123.456을 소수 셋째 자리에서 반올림 하려면 round (123.456, 2) 라고 작성함.
  * 결과는 123.46이 됨.



### 수 자료형의 연산

* 수 자료형에 대하여 **사칙연산**과 나머지 연산자가 많이 사용됨.
* 단, 나머지 연산자(/)를 주의해서 사용해야 함
  * 파이썬에서는 나머지 연산자(/)는 나눠진 결과를 실수형으로 반환함.
* 다양한 로직을 설계할 때 __나머지 연산자(%)__ 를 이용할 때가 많음
  * 예시)  a가 홀수인지 체크해야 하는 경우
* 파이썬에서는 몫을 얻기 위해 **몫 연산자(//)** 를 사용함.
* 이외에도 **거듭 제곱 연산자(**)** 를 비롯해 다양한 연산자들이 존재합니다.

## 4강) 파이썬 문법 - 리스트 자료형

* 여러 개의 __데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형__ 
* 리스트 대신에 배열 혹은 테이블이라고 부르기도 함

### 리스트 초기화
* 리스트는 대괄호`[]` 안에 원소를 넣어 초기화하며, 쉼표`,`로 원소를 구분함
* 비어있는 리스트를 선언하고자 할 때는 `list()` 혹은 간단히 `[]` 를 이용할 수 있음
* 리스트의 원소에 접근할 때는 인덱스 (index) 값을 괄호에 넣음
  * __인덱스는 0부터 시작함!__

``` python
a = [1,2,3,4,5,6,7,8,9]
print(a)

# 네 번째 원소만 출력 
print(a[3])
```

### 리스트의 인덱싱과 슬라이싱

* 인덱스 값을 입력하여 __리스트의 특정한 원소에 접근하는 것을 인덱싱(Indexing)__ 이라고 함
  * 파이썬의 인덱스 값은 양의 정수와 음의 정수를 모두 사용할 수 있음
  * 음의 정수를 넣으면 원소를 거꾸로 탐색하게 됨 ( -1 부터 )

``` python
a = [1,2,3,4,5,6,7,8,9]
print(a)

# 여덟 번째 원소만 출력
print(a[7])

# 뒤에서 첫 번째 원소만 출력
print(a[-1])

# 뒤에서 세 번째 원소만 출력
print(a[-3])

# 네 번째 원소 값 변경
a[3] = 7
print(a)
```

* 리스트에서 **연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱(Slicing)을 이용함**
  * 대괄호 안에 콜론`:`을 넣어서 **시작 인덱스**와 **끝 인덱스**를 설정할 수 있음
  * **끝 인덱스는 실제 인덱스보다 1을 더 크게 설정함**

```python
a = [1,2,3,4,5,6,7,8,9]

# 두 번째 원소부터 네 번째 원소까지
print(a[1:4])
```

### 리스트 컴프리헨션
> comprehension = 이해

* 리스트를 초기화하는 방법 중 하나
  * __대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화__ 할 수 있음

```python
# 0부터 9까지의 수를 포함하는 리스트
array = [i for i in range(10)] # 소스코드를 짧고 간결하게 사용 가능

print(array)

# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range (20) if i % 2 == 1]

print(array)

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i * i for i in range(1,10)]

print(array)
```

* 리스트 컴프리헨션은 **2차원 리스트를 초기화할 때 효과적으로 사용**될 수 있음.
* 특히 **N * M 크기**의 2차원 리스트를 한 번에 초기화 해야 할 때 매우 유용함
  
  * 좋은 예시: array = [[0] * m for _ in range (n)]
* 만약 2차원 리스트를 초기화할 때 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있음
  * 잘못된 예시: array = [[0] * m] * n
  * 위 코드는 **전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식**됩니다.

  ```python
  # N * M 크기의 2차원 리스트 초기화
  n = 4
  m = 3
  array = [[0]*m for _ in range (n)]
  print(array)
  
  # N * M 크기의 2차원 리스트 초기화 (잘못된 예시)
  n = 4
  m = 3
  array = [[0]*m ] * n
  print(array)
  
  array [1][1] = 5
  print(array) 
  
  # 실행 결과: [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]
  
  # 1,1 이 아닌 주소가 같은 2번째 열 모두가 5로 바뀜.
  ```

### 언더바는 언제 사용하나요?

* 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 **언더바(`_`)** 를 자주 사용합니다.

```python
for _ in range(5):
    print("Hello World")
```

### 리스트 관련 기타 메서드

* append( ): `변수명.append()` , 리스트에 원소를 하나 삽입할 때 사용함 => O(1) 
* sort( ): `변수명.sort()` , 기본 정렬 기능으로 오름차순으로 정렬함 => O(N*logN)
  * `변수명.sort(reverse = True)` , 내림차순으로 정렬함

* reverse( ): `변수명.reverse()` , 리스트의 원소 순서를 모두 뒤집어 놓음 => O(N)
* insert( ): `insert(삽입할 위치 인덱스, 삽입할 값)`,  특정한 인덱스 위치에 원소를 삽입할 때 사용함 => O(N)
* count( ): `변수명.count(특정 값)`, 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용함 => O(N)
* remove( ): `변수명.remove(특정 값)`, 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거함 => O(N)

```python
a = [1,2,3,4]
print("기본 리스트: ", a)

# 리스트에 원소 삽입
a.append(2)
print("삽입: ", a)

# 오름차순 정렬
a.sort( )
print("오름차순 정렬: ",a)

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬: ", a)

a = [4,3,2,1]

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기: ", a)

# 특정 인덱스에 데이터 추가
a.insert(2, 3)
print("인덱스 2에 3 추가: ", a)

# 특정 값인 데이터 개수 세기
print("값이 3인 데이터 개수: ", a.count(3))

# 특정 값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a)
```

### 리스트에서 특정 값을 가지는 원소를 모두 제거하기

``` python
a = [1,2,3,4,5,5,5]
remove_set = {3,5} # 집합 자료형 (추후에 다시 배움)

# remove_list에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)

## 결과 : [1, 2, 4]
```

## 5강) 파이썬 문법 - 문자열, 튜플 자료형
> str

### 문자열 자료형

* 문자열 변수를 초기화할 때는 큰따옴표나 작은따옴표를 이용함
* 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우가 있음
  * 전체 문자열을 큰 따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함할 수 있음
  * 반대로, 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표를 포함할 수 있음
  * 혹은 백슬래시`\` 를 사용하면, 큰따옴표나 작은따옴표를 원하는 만큼 포함시킬 수 있음

```python
data = "Don't you know \"Python\"?"
print(data)
```

### 문자열 연산

* 문자열 변수에 __덧셈(+)__ 를 이용하면 __문자열이 더해져서 연결(concentrate)__ 됨
* 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해짐
* 문자열에 대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있음
  * 다만 문자열은 특정 인덱스의 값을 변경할 수는 없음 __(immutable)__

```python
a = "Hello"
b = "World"
print(a+ " "+b)

a = "String"
print(a*3)
print(a[2:4])
```

### 튜플 자료형 (tuple)

* 튜플 자료형은 리스트와 유사하지만 다음과 같은 문법적 차이가 있음
  * 튜플은 __한 번 선언된 값을 변경할 수 없음!__
  * 리스트는 대괄호`[]`를 이용하지만, 튜플은 소괄호`()` 를 이용함

* 튜플은 리스트에 비해 __공간 효율적임__ (기능이 제한적이기 때문에 메모리를 더 적게 사용)

```python
a = (1,2,3,4,5,6,7,8,9)

# 네번째 원소만 출력
print(a[3])

# 두번째 원소부터 네번째 원소까지
print(a[1:4])
```

```python
# 튜플 사용 예제 (오류 발생하는 예제)
a = (1,2,3,4)
a[2] = 7

## 결과 : TypeError: 'tuple' object does not support item assignment
## 튜플은 원소 할당 불가능하다는 에러메시지
```

### 튜플을 사용하면 좋은 경우

* **서로 다른 성질**의 데이터를 묶어서 관리해야 할 때
  * 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용함
* 데이터의 나열을 **해싱(Hashing)의 키 값**으로 사용해야 할 때
  * 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있음
* 리스트보다 메모리를 효율적으로 사용해야 할 때

오류 수정









