# Django 프로그래밍 수업 요약

> 0126_10시부터 수업

### 웹의 기본 이해

* 서버: 정보 제공하는 보통의 웹사이트들이 이에 해당
* 클라이언트: 서버를 찾아 접속하는 컴퓨터가 이에 해당

#### 웹 프로그램의 구조 별 개념

* 프론트엔드: 프론트엔드는 보통 사용자들이 보는 화면의 모습을 결정함. **HTML, CSS, JavaScipt** 프로그래밍으로 보통 구성되고, 클라이언트의 웹 브라우저에서 코드가 실행되거나 그려짐
* 백엔드: 백엔드는 사용자가 접속하면 그에 맞는 데이터를 보내주기 위해 여러가지 처리를 하는 부분을 담당하는 로직을 구성함. 우리가 배울 **Django 기반의 Python 프로그래밍이나 데이터베이스** 등이 여기에 속함
  * (CGI, PHP, ASP, Servlet, NodeJS, **JSP, Spring MVC**) - 많이 쓰이는 핵심 백엔드 언어인듯
  * 장고는 조금 더 후발주자.

#### 서버- 클라이언트 간 통신 방향 별 개념

* ""요청 - 응답"" 통신
  * 클라이언트 요청 -> 서버 응답
* 응답 방식: 약 80% HTML, 이 외에 JSON, XML도 있음. 

### HTTP 프로토콜

* 웹의 기본 통신규약 (정의한 규칙)
* HTTP 프로토콜은 상태가 없는 프로토콜 -> 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 말

#### URL

* URL은 서버에 자원을 요청하기 위해 입력하는 영문 주소
* Protocol + Host + Port + resource path + Query
  * resource path가 생략되면 기본파일을 달라는 의미로 해석 - 주로 index.html)
* 예시: `https://www.domain.com:1234/path/to/resource?a=b&x=y`

#### HTTP 요청 메서드

* URL을 이용하면 서버에 특정 데이터 요청 할 수 있음
* 여기서 요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드를 이용함

* **get, post**, put, delete 
  * get이 기본 요청 방식

#### HTTP 상태 코드

* 2XX - 성공, 3XX - 리다이렉션, 4XX - 클라이언트 에러, 5XX - 서버 에러
  * 200은 요청 성공
  * 404는 요청한 자원 못 찾아서 실패
  * 500은 자원은 있지만 실행 에러



## Django (장고)

> 웹 서버 프로그래밍 중 하나
>
> 적은 코딩량으로 우리가 원하는 것을 구현 할 수 있으나 난이도가 있는 편

* 장고는 파이썬으로 작성된 오픈 소스 웹 어플리케이션 프레임워크. (MTV 패턴)

* 장고 개발환경 구축 (가상환경, 워드 파일) 

#### 라이브러리(API)란?

* **재사용이 필요한 기능으로 반복적인 코드 작성을 없애기 위해 언제든지 필요한 곳에서 호출하여 사용할 수 있도록 Class나 Function으로 만들어진 것**
* 미리 준비하여 제공한 느낌

#### 프레임워크란?

* 원하는 기능 구현에만 집중하여 빠르게 개발 할 수 있도록 기본적으로 필요한 기능을 갖추고 있는 것으로 라이브러리가 포함되어 있음
* **BUT, 프레임워크만으로는 실행되지 않으며 기능 추가를 해야 되고, 프레임워크에 의존하여 개발해야 되며 프레임워크가 정의한 규칙을 준수해야 함**
* "반제품 형식"으로 나와서 꼭 양식에 맞춰서 나머지를 채우면 됨
* 최근에는 프레임워크 활용 많아짐 -> 빠르고 규격화 되어있음, 또한 유지보수하기가 좋다!
  * Django도 프레임워크 기반
  * studyproject에 전역적인 소스들이 있음

### 장고 프로그램의 개발 패턴

* 장고 프레임 워크에서는 기존 MVC 패턴에서 View를 Template, Controller는 View라고 표현하며, **MTV**라고 함
* 클라이언트 요청받아서 기능을 수행하는 역할 - **View** -> Python으로 개발 (중간관리자)
* 응답하는 역할 (프레젠테이션 역할) - Template -> HTML로 개발
* Model은 파이썬으로 필요하면 만들고, 안만들기도 함. (DB 동작, 자동화 많이 되어있음)
* 핵심은 클라이언트가 요청해서 서비스하는 로직과 응답하는 로직을 나눠서 개발함!
* 강의교안 1 리뷰보고, 복습 필요!

### 장고의 처리 흐름

* 웹 클라이언트의 요청을 받아 장고에서 MTV 모델에 따라 처리하는 과정
  1. 클라이언트로부터 요청 받으면 URLconf 모듈을 이용하여 URL 분석
  2. URL 분석 결과를 통해 해당 URL에 매칭되는 뷰들 실행
  3. 뷰는 자신의 로직을 실행하고, 데이터베이스 처리가 필요하면 모델을 통해 처리하고 그 결과 반환
  4. 뷰는 자신의 로직처리가 끝나면!, 템플릿을 사용하여 클라이언트에 전송할 HTML 파일을 생성
  5. 뷰는 최종 결과로 HTML 파일을 클라이언트에게 보내 응답한다. 



### 이 외 코멘트

* templates 사용하는 앱 생성, 추가 시  studyproject - setting.py에서 INSTALLED_APPS에 넣어주어야 함
* main의 urls.py: `path('secondapp/', include('secondapp.urls'))` 설명
* templates 파일은 templates 폴더를 만들어서 거기에 넣는게 약속임
* urls 파일들 mapping 하는 방법
* first.app: 맛보기로 view만 있는 간단한 예제

* static 폴더 : 이미지와 같은 정적인 파일 넣어두는 폴더, 클라이언트한테 작업없이 던져지는 파일
  *  `STATIC_URL = '/static/'` : settings에 디폴트값으로 있음

> 0127 수업 시작!

#### 장고 강의교안 1 (가상환경부터 리뷰하면서 설명)

* `127.0.0.1` : 모든 컴터에서 자기 컴터 도메인 의미함
  * 즉, localhost 의미함
* 장고 프로그래밍에서 가상환경 만드는건 필수는 아님.
  * 테마(데이터 분석, 웹 서버)에 맞게 가상환경을 만들고, 이에 맞춰 추가 API 설치하는 것이 일반적 
* 경로 탐색에서 `cd \` 처럼 백슬래쉬부터 시작하면 최상위부터 경로 탐색을 시작한다는 의미

* 장고 프로젝트 생성: `cd 명령어 두번` -> `activate` -> DJANGOexam으로 디렉토리 이동

 -> `django-admin startproject '프로젝트 이름'`

* `settings.py` : 장고 프로그래밍에서 일어나는 환경설정하는 파일
* `urls.py`: urlpatterns에서 path 설정

#### secondapp 코드 설명

* HttpRequest: HTTP 프로토콜 기반으로 요청이 왔을 때 요청 관련 정보를 제공하는 객체, **요청 처리**
  
  * 뷰함수가 호출될 때 아규먼트로 전달된다. (장고 서버가 객체를 생성)
* HttpResponse: HTTP 프로토콜기반으로 온 요청에 대한 응답시 사용하는 객체, **응답 처리**
* 응답 내용을 담는다. (HTML 태그문자열, 템플릿을 사용한 랜더 객체)
* 템플릿 변수: {{ 변수명 }} => 값 표현

  * 변수는 뷰가 넘겨준 딕셔너리의 key 이름임
  * 꼭 딕셔너리로 전달해야 함
* 템플릿 태그(로직): {% 로직 %} => 로직 구현 

  * 화면에 영향은 없으나 post일때는 토큰이 있어야됨. -> 보안때문에 
* `<a>` 태그로 요청하는건 무조건 get 방식임
* get 방식: URL 직접 입력할 때, 하이퍼링크 요청할 때,  form태그의 method 속성 get일 때
* post 방식: form태그의 method 속성 post일 때
  * 상대적으로 엄격한 보안, 뒤에 / 안붙이면 에러남

#### HttpRequest와 HttpResponse

* 장고는 request와 response 객체로 서버와 클라이언트가 정보를 주고 받음

  * 이를 위해 django.http 모듈에서 HttpRequest와 HttpResponse API를 제공함

* 서버 - 클라이언트 통신 시 아래와 같은 절차로 데이터가 오고감

  1. 특정 페이지가 요청(request)되면, 장고는 요청 시 메타데이터(여러 다양한 정보)를 포함하는 HttpRequest 객체를 생성

  2. 장고는 urls.py에서 정의한 특정 View 함수에 첫 번째 인자로 해당 객체(request)를 전달
  3. 해당 View는 결과값을 HttpResponse 혹은 JsonResponse 객체에 담아 전달

* 뒤에 `/` 안붙이면 `/` 붙여서 통신이 한번 더 일어남
  
  * 불필요한 요청이 추가되는 것이라 URL 끝에 `/` 붙여서 요청해야함!

#### secondapp - exam2_1

* get 함수 설명 
* hidden 내용 설명
* get 방식은 쿼리 문자열이 주석빌드에 보임
* post 방식은 서버에게 전달되는 쿼리 문자열이 브라우저에 보이지 않음. 
  * 로그인, 회원가입시에는 이 방식이 좋음

오늘의 핵심: get 방식 처리와 post 방식의 처리하는 방법과 차이점 아는 것

#### Query 문자열

* HTTP 클라이언트가 HTTP 서버 요청시 서버에서 요청하려는 대상의 URI가 전달되는데, 이 때 함께 전달될 수 있는 문자열
* name=value 형식으로 구성
* 여러 개의 name=value가 사용될 때는 & 기호로 구분해야 함
* 영문과 숫자는 그대로 전달되지만 한글과 특수문자들은 %기호와 16진수 코드값으로 전달됨 (UTF-)
* 공백문자는 + 기호 또는 %20로 전달된다. 
* Query 문자열을 가지고 HTTP 서버에게 정보를 요청할 때는 두 가지 요청 방식중에서 한 개를 선택할 수 있다.
  * GET: Query 문자열이 외부에 보여짐. 요청 URL 뒤에 ? 기호와 함께 전달되기 때문
  * POST: Query 문자열이 외부에 보여지지않고, 길이에 제한이 없다. 

#### secondapp.exam3~ 

* exam3:  `선택한 번호 : {{ number }}` -> number라는 키를 가진 딕셔너리 값인 5가 출력

* exam4: 리스트를 view에서 templates로 전달함
  * 템플릿 태그 이용한 예시 (html 파일 안에서 파이썬 처럼 코딩함)
  * for 태그와 endfor 태그, contents로 구성
* 템플릿 태그 설명 - 강의교안 (csrf_token)

* exam5 : Django의 if문과 else, endif 예제

  * 쿼리에 내용 주는 것 배움. 

* exam6: 쿼리문자열에서는 숫자도 문자로 인식해서 넘어옴!

  * context = None이 넘어오면 form태그 출력

  * exam6.html의 "`<input>` 태그는 name 속성의 값"과 "쿼리에서 추출하고자 하는 이름"과 똑같아야한다. 

    * ```html
      <input type="number" name="number" placeholder="숫자를 입력하세요" required>
      ```

    * ```python
      def exam6(request) :
          if request.method == 'POST':
              num = int(request.POST['number'])
              context = { 'num' : num*num }
          else :
               context = None
          return render(request, 'exam6.html', context)
      ```

      + name = "**Number**"와 request.Post['**number**'] 가 같아야한다.  

> 강의교안 내일 다시 한번 정리 + exam6을 통해 실습 아침에 해결 
>
> 0127 수업 끝. 